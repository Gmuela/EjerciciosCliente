(function(window) 
{
    // Generacion del namespace psd.framework
    if(window.psd==undefined) { window.psd = {}; }
    if(window.psd.framework==undefined) { window.psd.framework = {}; }
    if(window.psd.framework.events==undefined) { window.psd.framework.events = {}; }
    if(window.psd.framework.parser==undefined) { window.psd.framework.parser = {}; }
    if(window.psd.framework.mediator==undefined) { window.psd.framework.mediator = {}; }
    if(window.psd.framework.mediator.jsonp==undefined) { window.psd.framework.mediator.jsonp = {}; }
    if(window.psd.framework.utils==undefined) { window.psd.framework.utils = {}; }
    
    window.psd.framework.debug = false;
    
    if(window.location.href.indexOf("debug")!=-1) { window.psd.framework.debug = true; }
    
})(window);(function()
{
    // Generacion del namespace psd.framework (por si no esta creado)
    if(window.psd==undefined) { window.psd = {}; }
    if(window.psd.framework==undefined) { window.psd.framework = {}; }

    /**
     * navigator.userAgent =>
     * Chrome:  "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_7) AppleWebKit/534.24 (KHTML, like Gecko) Chrome/11.0.696.57 Safari/534.24"
     * Opera:   "Opera/9.80 (Macintosh; Intel Mac OS X 10.6.7; U; en) Presto/2.7.62 Version/11.01"
     * Safari:  "Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_7; en-us) AppleWebKit/533.21.1 (KHTML, like Gecko) Version/5.0.5 Safari/533.21.1"
     * IE:      "Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C)"
     * Firefox: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0) Gecko/20100101 Firefox/4.0"
     * iPhone:  "Mozilla/5.0 (iPhone Simulator; U; CPU iPhone OS 4_3_2 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8H7 Safari/6533.18.5"
     * iPad:    "Mozilla/5.0 (iPad; U; CPU OS 4_3_2 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8H7 Safari/6533.18.5",
     * Android: "Mozilla/5.0 (Linux; U; Android 2.3.4; en-us; T-Mobile G2 Build/GRJ22) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1"
    */

    var ua = navigator.userAgent
        , t = true
        , ie = /msie/i.test(ua)
        , ie11 = /.NET/i.test(ua)
        , chrome = /chrome/i.test(ua)
        , safari = /safari/i.test(ua) && !chrome
        , iphone = /iphone/i.test(ua)
        , ipad = /ipad/i.test(ua)
        , android = /android/i.test(ua)
        , opera = /opera/i.test(ua)
        , firefox = /firefox/i.test(ua)
        , gecko = /gecko\//i.test(ua)
        , seamonkey = /seamonkey\//i.test(ua)
        , webkitVersion = /version\/(\d+(\.\d+)?)/i
        , o;

    //Sistema operativo
    var appVersion = window.navigator.userAgent
        , win7 = /Windows NT 6.1/i.test(appVersion)
        , winVista = /Windows NT 6.0/i.test(appVersion)
        , oSX = /Mac OS X 10_7/i.test(appVersion);


    // Completa la información sobre el user agent
    function detect() 
    {
		if (ie11){ o = { msie: t, version: 11 }; }
        if (ie) { o = { msie: t, version: ua.match(/msie (\d+(\.\d+)?);/i)[1] }; }
       
        if (chrome) { o = { webkit: t, chrome: t, version: ua.match(/chrome\/(\d+(\.\d+)?)/i)[1]}; }
        
        if (iphone || ipad) 
        {
            o = {webkit: t, mobile: t, ios: t, iphone: iphone, ipad: ipad };
            // WTF: version is not part of user agent in web apps
            if (webkitVersion.test(ua)) { o.version = ua.match(webkitVersion)[1];}
        }
        
        if (android) { o = { webkit: t, android: t, mobile: t, version: "0"/*ua.match(webkitVersion)[1]*/ }; }
        
		if (safari) {  
			var aux = ua.match(webkitVersion);
			if (aux){
				o = { webkit: t, safari: t, version: aux[1] };
			}			
		}  
        
		if (opera) {  
			var aux = ua.match(webkitVersion);
			if (aux){
				o = { opera: t, version: aux[1] };
			}			
		}
        
        if (gecko) 
        {
            o = { gecko: t, mozilla: t, version: ua.match(/firefox\/(\d+(\.\d+)?)/i)[1] };
            if (firefox) { o.firefox = t; }
        }
        
        if (seamonkey) { o = { seamonkey: t, version: ua.match(/seamonkey\/(\d+(\.\d+)?)/i)[1] }; }
        
        return o;
    }
    
    // Completa la información sobre el modo de compatibilidad
    function detectCompatibility(ua)
    {
        if (ua.msie && ua.version<9) { return 1; }
        return 0;
    }

    function detectMp3AudioCompatible(ua){
        //explorer > 9
        if(ua.msie && ua.version>8) return true;
        if(chrome) return true;
        if (ua.safari && ua.version >= 3.1) return true;
        if ((ua.firefox && ua.version >= 21 && win7) || (ua.firefox && ua.version >= 22 && winVista) || (ua.firefox && ua.version >= 22 && oSX)) return true;

        return false;
    }

    function detectMp4AudioCompatible(ua){

        return detectMp3AudioCompatible(ua);
    }

    function detectAacAudioCompatible(ua){

        return detectMp3AudioCompatible(ua);;
    }

    function detectMp4VideoCompatible(ua){
        //explorer > 9
        if(ua.msie && ua.version>8) return true;
        if(chrome) return true;
        if (ua.safari && ua.version >= 3.1) return true;
        if ((ua.firefox && ua.version >= 21 && win7) || (ua.firefox && ua.version >= 22 && winVista) || (ua.firefox && ua.version >= 22 && oSX)) return true;

        return false;
    }

    function detectOggVideoCompatible(ua){
        if(chrome) return true;
        if (ua.firefox && ua.version >= 3.5) return true;
        if (ua.gecko && ua.version > 1.9) return true;
        if (ua.opera && ua.version >= 10.50) return true;

        return false;
    }

    function detectWebmVideoCompatible(ua){
        //explorer > 9
        if(chrome) return true;
        if (ua.firefox && ua.version >= 4.2) return true;
        if (ua.gecko && ua.version >= 2.0) return true;
        if (ua.opera && ua.version >= 10.60) return true;

        return false;
    }

    // Inicializamos la información de user agent
    psd.framework.ua = detect();
    
    // Detectamos el modo de compatibilidad
    psd.framework.compatibility = detectCompatibility(psd.framework.ua);

    psd.framework.mp3AudioCompatible = detectMp3AudioCompatible(psd.framework.ua);
    psd.framework.mp4AudioCompatible = detectMp4AudioCompatible(psd.framework.ua);
    psd.framework.aacAudioCompatible = detectAacAudioCompatible(psd.framework.ua);

    psd.framework.mp4VideoCompatible = detectMp4VideoCompatible(psd.framework.ua);
    psd.framework.oggVideoCompatible = detectOggVideoCompatible(psd.framework.ua);
    psd.framework.webmVideoCompatible = detectWebmVideoCompatible(psd.framework.ua);

})();function getDevice()
{
	var device = {};
            device.agent = navigator.userAgent;
            device.mobile = is_MobileDevice(device.agent);
		 
	return device;
}

function is_MobileDevice(agent)
{
    var isMobile = (
        (agent.indexOf('iPhone') != -1) ||
        (agent.indexOf('iPod') != -1) ||
		(agent.indexOf('iPad') != -1) ||
		(agent.indexOf('Android') != -1)
    );
    return isMobile;
}

// TODO - Externalizar utilidad de control de version de flash
var FlashDetect = new function(){
	var self = this;
	self.release = "1.0.2";
	self.installed = false;
	self.major = -1;
	self.minor = -1;
	self.revision = -1;
	self.revisionStr = "";
	self.activeXVersion = "";
	
	var activeXDetectRules = [
		{
			"name":"ShockwaveFlash.ShockwaveFlash.7",
			"version":function(obj){
				return getActiveXVersion(obj);
			}
		},
		{
			"name":"ShockwaveFlash.ShockwaveFlash.6",
			"version":function(obj){
				var version = "6,0,21";
				try{
					obj.AllowScriptAccess = "always";
					version = getActiveXVersion(obj);
				}catch(err){}
				return version;
			}
		},
		{
			"name":"ShockwaveFlash.ShockwaveFlash",
			"version":function(obj){
				return getActiveXVersion(obj);
			}
		}
	];
	
	var getActiveXVersion = function(activeXObj){
		var version = -1;
		try{
			version = activeXObj.GetVariable("$version");
		}catch(err){}
		return version;
	};
	
	var getActiveXObject = function(name){
		var obj = -1;
		try{
			obj = new ActiveXObject(name);
		}catch(err){}
		return obj;
	};
	
	var parseActiveXVersion = function(str){
		var versionArray = str.split(",");//replace with regex
		return {
			"major":parseInt(versionArray[0].split(" ")[1], 10),
			"minor":parseInt(versionArray[1], 10),
			"revision":parseInt(versionArray[2], 10),
			"revisionStr":versionArray[2]
		};
	};
	
	var parseRevisionStrToInt = function(str){
		return parseInt(str.replace(/[a-zA-Z]/g, ""), 10) || self.revision;
	};
	
	self.majorAtLeast = function(version){
		return self.major >= version;
	};
	
	self.FlashDetect = function(){
		if(navigator.plugins && navigator.plugins.length>0){
			var type = 'application/x-shockwave-flash';
			var mimeTypes = navigator.mimeTypes;
			if(mimeTypes && mimeTypes[type] && mimeTypes[type].enabledPlugin && mimeTypes[type].enabledPlugin.description){
				var desc = mimeTypes[type].enabledPlugin.description;
				var descParts = desc.split(' ');//replace with regex
				var majorMinor = descParts[2].split('.');
				self.major = parseInt(majorMinor[0], 10);
				self.minor = parseInt(majorMinor[1], 10); 
				self.revisionStr = descParts[3];
				self.revision = parseRevisionStrToInt(self.revisionStr);
				self.installed = true;
			}
		}else if(navigator.appVersion.indexOf("Mac")==-1 && window.execScript){
			var version = -1;
			for(var i=0; i<activeXDetectRules.length && version==-1; i++){
				var obj = getActiveXObject(activeXDetectRules[i].name);
				if(typeof obj == "object"){
					self.installed = true;
					version = activeXDetectRules[i].version(obj);
					if(version!=-1){
						var versionObj = parseActiveXVersion(version);
						self.major = versionObj.major;
						self.minor = versionObj.minor; 
						self.revision = versionObj.revision;
						self.revisionStr = versionObj.revisionStr;
						self.activeXVersion = version;
					}
				}
			}
		}
	}();
};(function(namespace) {
	
    // Statics const parametters
    Log.LEVEL_LOG = 0;
    Log.LEVEL_DEBUG = 1;
    Log.LEVEL_INFO = 2;
    Log.LEVEL_WARNING = 3;
    Log.LEVEL_ERROR = 4;
    Log.LEVEL_FATAL = 5;
	
    // Static public variables
    Log.enabled = true;
    Log.level = Log.LEVEL_LOG;

    // Static private const
    Log._LEVEL_LOG_NAME = "log";
    Log._LEVEL_DEBUG_NAME = "debug";
    Log._LEVEL_INFO_NAME = "info";
    Log._LEVEL_WARNING_NAME = "warning";
    Log._LEVEL_ERROR_NAME = "error";
    Log._LEVEL_FATAL_NAME = "fatal";
	
    // Static private variables
    Log._counter = 0;
		
    // Construct
    function Log() {
        throw "Log cannot be instantiated";
    }

    // Static public methods
    Log.log = function() {
        if (window.console && Log.enabled && arguments.length > 0) {
            if (Log.level <= Log.LEVEL_LOG) {
                _print(Log._LEVEL_LOG_NAME, Log._counter++, arguments);
            }
        }
    };
	
    Log.debug = function() {
        if (window.console && Log.enabled && arguments.length > 0) {
            if (Log.level <= Log.LEVEL_DEBUG) {
                _print(Log._LEVEL_DEBUG_NAME, Log._counter++, arguments);
            }
        }
    };
	
    Log.info = function() {
        if (window.console && Log.enabled && arguments.length > 0) {
            if (Log.level <= Log.LEVEL_INFO) {
                _print(Log._LEVEL_INFO_NAME, Log._counter++, arguments);
            }
        }
    };
	
    Log.warn = function() {
        if (window.console && Log.enabled && arguments.length > 0) {
            if (Log.level <= Log.LEVEL_WARNING) {
                _print(Log._LEVEL_WARNING_NAME, Log._counter++, arguments);
            }
        }
    };
	
    Log.error = function() {
        if (window.console && Log.enabled && arguments.length > 0) {
            if (Log.level <= Log.LEVEL_ERROR) {
                _print(Log._LEVEL_ERROR_NAME, Log._counter++, arguments);
            }
        }
    };
	
    Log.fatal = function() {
        if (window.console && Log.enabled && arguments.length > 0) {
            if (Log.level <= Log.LEVEL_FATAL) {
                _print(Log._LEVEL_FATAL_NAME, Log._counter++, arguments);
            }
        }
    };
	
    Log.clear = function() {
        Log._counter = 0;
    };
	
    // Static private methods
    function _print(type, counter, arguments) {
        var data = "";
        var i = 0;
        for (i=0; i < arguments.length; i++) {
            data += " " + (arguments[i]);
            data += i == arguments.length - 1 ? "" : ",";
        }
        if(psd.framework.debug) {console.log("[" + counter + "] " + type + " -> " + data);}
    }
	
    // Ad window context
    namespace.Log = Log;
	
}(window));(function(namespace) {

    /**
     * Clase base para todos los eventos
     * @constructor
     */
    function Event(type) {
        
        /**
         * Tipo de evento
         */
        this.type = type;
        
        /**
         * Objeto que produce el evento
         */
        this.target = null;
    }

    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.Event = Event;

}(psd.framework));(function(namespace) {

    /**
     * Clase base para todas las clases que lanzan eventos
     * @constructor
     */
    function EventDispatcher() {
		
        // Mapa de listeners registrados
        var _eventListeners = {};
		
        /**
         * Registra un objeto para que pueda recibir notificaciones del evento deseado
         * @param type El tipo de evento
         * @param listener La funcion que procesa el evento
         * @param scope Scope opcional para la ejecución del listener. Si no se recibe,
         *              el listener se ejecutará dentro del contexto "window"
         */
        this.addEventListener = function(type, listener, scope) 
        {
            if (!_eventListeners[type]) { _eventListeners[type] = []; }            
            _eventListeners[type].push({listener: listener, scope: scope});
        };

        /**
         * Elimina un objeto para que deje de recibir notificaciones del evento deseado
         * @param type El tipo de evento
         * @param listener La funcion que procesa el evento
         * @param scope Scope opcional para la ejecución del listener. Si no se recibe,
         *              el listener se ejecutará dentro del contexto "window"
         */
        this.removeEventListener = function(type, listener, scope) 
        {
            var i = 0, 
                listeners = _eventListeners[type].length,
                eventListeners = [];
                
            for (i = 0; i < listeners; i++) 
            {
                if (_eventListeners[type][i].listener !== listener || _eventListeners[type][i].scope !== scope) { 
                    eventListeners.push(_eventListeners[type][i]);
                }
            }

            _eventListeners[type] = eventListeners;
        };
	
        /**
         * Dispara un evento
         * @param event El evento que se quiere disparar
         */
        this.dispatchEvent = function(event) 
        {
            var i = 0;
            if(typeof(event.type)!="undefined")
            {
                event.target = this;
                if (_eventListeners[event.type]) {
                    for (i = 0; i < _eventListeners[event.type].length; i++) {
                        _eventListeners[event.type][i].listener.apply(_eventListeners[event.type][i].scope, [event]);
                    }
                }
            }
        };

    }

    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.EventDispatcher = EventDispatcher;

}(psd.framework));(function(namespace) {
    
    // Inheritance class
    ErrorEvent.prototype = new psd.framework.Event();
    
     /**
     * Clase base para todos los eventos de tipo Error
     * @constructor
     */
    function ErrorEvent(type, error) {
        
        psd.framework.Event.call(this, type);
        var errorValid = typeof(error) != "undefined" && error != null;
        
        /**
         * Id del error
         */
        this.id = errorValid && error.id ? error.id : "";
        
        /**
         * Mensaje asociado al error
         */
        this.message = errorValid && error.message ? error.message : "";
    }
    
    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.ErrorEvent = ErrorEvent;

}(psd.framework));
(function(namespace) {
    
    // Inheritance class
    TimerEvent.prototype = new psd.framework.Event();

    /**
     * Define el valor de la constante TIMER
     */
    TimerEvent.TIMER = "timer";
    
    /**
     * Define el valor de la constante TIMER_COMPLETE
     */
    TimerEvent.TIMER_COMPLETE = "timerComplete";
    
    /**
     * Un objeto Timer dispara un TimerEvent cada vez que completa el intervalo 
     * de tiempo definido en la propiedad Timer.delay
     * @constructor
     */
    function TimerEvent(type) 
    {
        // Super
        psd.framework.Event.call(this, type);
    }
    
    // Incluimos la declaracion de la clase en el namespace psd.fenix	
    namespace.TimerEvent = TimerEvent;

})(psd.framework.events);(function(namespace) {

    // Inheritance class
    Mediator.prototype = new psd.framework.EventDispatcher();

    // Constants
    Mediator._REQUEST_OK_CODE = 200;
    Mediator._REQUEST_ERROR_CODE = 404;
    
    Mediator._STATE_REQUEST_NOT_INITIALIZED_CODE = 0;
    Mediator._STATE_SERVER_CONECTION_STABLISHED_CODE = 1;
    Mediator._STATE_REQUEST_RECEIVED_CODE = 2;
    Mediator._STATE_REQUEST_PROCESSING_CODE = 3;
    Mediator._STATE_REQUEST_FINISHED_CODE = 4;
    
    Mediator.REQUEST_GET  = "GET";
    Mediator.REQUEST_POST = "POST";
    Mediator.REQUEST_HEAD = "HEAD";
    
    Mediator.RESPONSE_TEXT = "text";
    Mediator.RESPONSE_XML = "xml";
    Mediator.RESPONSE_JSON = "json";
    Mediator.RESPONSE_JSONP = "jsonp";
    
    /**
     * ID autoincremental de las peticiones realizadas por este mediator
     */
    Mediator._nextID = 0;
    
    /**
     * Devuelve el siguiente id de peticion para este mediator
     */
    Mediator.getNextKey = function() {
        return Mediator._nextID++;
    };
	
    /**
     * Mediator es una clase generica que puede ser utilizada para interactuar
     * con servicios de datos de manera asincrona
     * @constructor
     */
    function Mediator() 
    {
        // Super
        psd.framework.EventDispatcher.call(this);
		
        // Id de la peticion actual
        var _id = "0";
        
        // Url de la peticion actual
        var _url = "";
        
        // Parser de la peticion actual
        var _parser = null;

        //Indica si se utilizará XDomainRequest en navegadores Explorer <= 9 para la carga Ajaz con CORS
        //Por defecto está inhabilidado debido a los problemas que ocasiona esta clase
        var _corsIE = false;

        // Tipo de respuesta de la peticion actual
        var _type = Mediator.RESPONSE_XML;
        
        // Referencia dinamica a la instancia para no perder el contexto dentro
        // de las respuestas asincronas del XMLHttpRequest
        var _mediatorInstance = this;

        //Nombre de la función que se llama en JSONP
        var _customJSONPCallback = null;
        //Parámetro que se pasará a la url para solicitar JSONP
        var _customCallbackParam = null;

        var _deferredJSONP = (function(mediator) {return function(data) {_jsonp.apply(mediator,[data]);}})(this);
        var _jsonp = function(responseData)
        {
            var parserResult = responseData,
                mediatorResult = new psd.framework.MediatorResult( psd.framework.MediatorResult.MEDIATOR_SUCCESS_CODE
                                                    , psd.framework.MediatorResult.MEDIATOR_SUCCESS
                                                    , parserResult );
                                                    
            _mediatorInstance.dispatchEvent(new psd.framework.MediatorEvent(psd.framework.MediatorEvent.MEDIATE_COMPLETE, _id, mediatorResult));
        };

        this.corsIE = function(value){
            if(value && value!=_corsIE) {_corsIE = value;}
            return _corsIE;
        };

        this.setCustomCallback = function(customCallback){
            _customJSONPCallback = customCallback;
        };

        /**
         * Inicia la mediacion solicitada
         * @param url La url de los datos
         * @param parser El parser que se utiliza para analizar la respuesta
         * @param type El tipo de respuesta (TEXT, XML, JSON)
         */
         this.mediate = function(url, parser, type) 
        {
            var xmlhttp, script,src, separator
                responseData = "",
                mediationID = Mediator.getNextKey();
            
            _id = "mediate_" + mediationID;
            _url = url;
            _parser = parser;
            if (type && (type == Mediator.RESPONSE_TEXT || 
                        type == Mediator.RESPONSE_XML || 
                        type == Mediator.RESPONSE_JSON ||
                        type == Mediator.RESPONSE_JSONP)) 
            {
                _type = type;
            }

            if(_type == Mediator.RESPONSE_JSONP)
            {
                script = document.createElement('script');
                script.setAttribute("type", "text/javascript");
                if (_customJSONPCallback){
                    script.setAttribute("src", url);
                    window[_customJSONPCallback] = _deferredJSONP;
                }else{
                    separator = (url.indexOf("?")>-1)? "&":"?";
                    script.setAttribute("src", url + separator + "jsonp=psd.framework.mediator.jsonp." + _id);
                    psd.framework.mediator.jsonp[_id] = _deferredJSONP;
                }
                document.getElementsByTagName("head")[0].appendChild(script);
            } else {

				if ((window.XDomainRequest) && _corsIE){ //IE 8, modo no estándar de realizar peticiones Ajax que soporten CORS
					xmlhttp = new XDomainRequest();
					xmlhttp.onerror = function(){
                        mediatorResult = new psd.framework.MediatorResult( psd.framework.MediatorResult.MEDIATOR_ERROR_CODE
                            , psd.framework.MediatorResult.MEDIATOR_ERROR
                            , null
                        );
                        _mediatorInstance.dispatchEvent(new psd.framework.MediatorEvent(psd.framework.MediatorEvent.MEDIATE_ERROR
                            , _id
                            , mediatorResult));
                    };
                    xmlhttp.onload = function(){

						//creación del xml a partir del string

                        switch (_type) {
                            case Mediator.RESPONSE_TEXT:
                                responseData = xmlhttp.responseText;
                                break;

                            case Mediator.RESPONSE_XML:
                                responseData = new ActiveXObject('Microsoft.XMLDOM');
                                responseData.async='false';
                                responseData.loadXML(xmlhttp.responseText);
                                break;

                            case Mediator.RESPONSE_JSON:
                                responseData = xmlhttp.responseText;
                                break;
                        }

						var parserResult = _parser.parse(responseData);
							mediatorResult = new psd.framework.MediatorResult( psd.framework.MediatorResult.MEDIATOR_SUCCESS_CODE
								, psd.framework.MediatorResult.MEDIATOR_SUCCESS
								, parserResult
								);
							_mediatorInstance.dispatchEvent(new psd.framework.MediatorEvent(psd.framework.MediatorEvent.MEDIATE_COMPLETE
																									, _id
																									, mediatorResult));
					}
				}else{

					// Code for Firefox, Chrome, Opera, Safari
					if (window.XMLHttpRequest) {
						xmlhttp = new XMLHttpRequest();
					}
					else { // code IE6 (no soporta CORS)
						xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
					}

					xmlhttp.onreadystatechange = function() {

						switch (xmlhttp.readyState) {
							case Mediator._STATE_REQUEST_NOT_INITIALIZED_CODE:
								break;

							case Mediator._STATE_SERVER_CONECTION_STABLISHED_CODE:
								break;

							case Mediator._STATE_REQUEST_RECEIVED_CODE:
								break;

							case Mediator._STATE_REQUEST_PROCESSING_CODE:
								break;

							case Mediator._STATE_REQUEST_FINISHED_CODE:
								var mediatorResult;

								if (xmlhttp.status == Mediator._REQUEST_OK_CODE) {
									switch (_type) {
										case Mediator.RESPONSE_TEXT:
											responseData = xmlhttp.responseText;
											break;

										case Mediator.RESPONSE_XML:
											responseData = xmlhttp.responseXML;
											break;

										case Mediator.RESPONSE_JSON:
											responseData = xmlhttp.responseText;
											break;
									}

									var parserResult = _parser.parse(responseData);
									mediatorResult = new psd.framework.MediatorResult( psd.framework.MediatorResult.MEDIATOR_SUCCESS_CODE
										, psd.framework.MediatorResult.MEDIATOR_SUCCESS
										, parserResult
										);
									_mediatorInstance.dispatchEvent(new psd.framework.MediatorEvent(psd.framework.MediatorEvent.MEDIATE_COMPLETE
																									, _id
																									, mediatorResult));
								}
								else {
									mediatorResult = new psd.framework.MediatorResult( psd.framework.MediatorResult.MEDIATOR_ERROR_CODE
										, psd.framework.MediatorResult.MEDIATOR_ERROR
										, null
										);
									_mediatorInstance.dispatchEvent(new psd.framework.MediatorEvent(psd.framework.MediatorEvent.MEDIATE_ERROR
																									, _id
																									, mediatorResult));
								}
								break;
						};
					};
				};

                xmlhttp.open(Mediator.REQUEST_GET, _url, true);
                xmlhttp.send();
            }
        };
		
        return _id;
    }
	
    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.Mediator = Mediator;
	
}(psd.framework));(function(namespace) {
    
    // Inheritance class
    MediatorEvent.prototype = new psd.framework.Event();
    
    /**
     * La peticion ha concluido correctamente
     */
    MediatorEvent.MEDIATE_COMPLETE = "mediate_complete";
    
    /**
     * Ha sucedido un error durante la peticion
     */
    MediatorEvent.MEDIATE_ERROR = "mediate_error";
    
    /**
     * MediatorEvent es el evento general que todo Mediator dispara como resultado
     * de sus peticiones
     * @param type Tipo del evento
     * @param id Id de la peticion
     * @param mediatorResult Resultado de la peticion
     * @constructor
     */
    function MediatorEvent(type, id, mediatorResult) 
    {
        // Super
        psd.framework.Event.call(this, type);

        this.id = id;
        this.result = mediatorResult;
    }
	
    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.MediatorEvent = MediatorEvent;

}(psd.framework));(function(namespace) {
	
    // Constants
    MediatorResult.MEDIATOR_SUCCESS_CODE = 0;
    MediatorResult.MEDIATOR_ERROR_CODE = 1;
    MediatorResult.MEDIATOR_SECURITY_ERROR = 2;
    MediatorResult.MEDIATOR_IO_ERROR = 3;
    
    MediatorResult.MEDIATOR_SUCCESS = "mediator_success";
    MediatorResult.MEDIATOR_ERROR = "mediator_error";
    MediatorResult.MEDIATOR_SECURITY_ERROR = "mediator_security_error";
    MediatorResult.MEDIATOR_IO_ERROR = "mediator_io_error";

    /**
     * MediatorResult es una clase que empaqueta de manera general el resultado
     * de una peticion a un servicio a traves de un Mediator
     * @param code Codigo de respuesta
     * @param msg Mensaje de respuesta
     * @param parserResult Resultado del parseo de los datos recibidos
     * @constructor
     */
    function MediatorResult(code, msg, parserResult) 
    {
        this.code = code;
        this.msg = msg;
        this.parserResult = parserResult;
    }
	
    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.MediatorResult = MediatorResult;

}(psd.framework));(function(namespace) {

    /**
     * Parser es la clase basica de la que extiende cualquier Parser para el
     * tratamiento del resultado de una peticion de datos
     * @constructor
     */
    function Parser() {
		
        /**
         * Analiza los datos recibidos y los devuelve en el formato deseado. Por
         * defecto, el parser se limita a devolver los datos sin tratarlos.
         * @param data Los datos recibidos
         * @return Un ParserResult con el resultado del parseo
         */
        this.parse = function(data) 
        {
            return new psd.framework.ParserResult(psd.framework.ParserResult.PARSER_SUCCESS_CODE
                                                    , psd.framework.ParserResult.PARSER_SUCCESS
                                                    , data);
        };
    }
	
    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.Parser = Parser;

}(psd.framework));(function(namespace) {

    // Inheritance class
    JSONParser.prototype = new psd.framework.Parser();

    /**
     * JSONParser es un parser para datos en formato JSON. Si está disponible, 
     * aplica la función nativa JSON.parse al resultado recibido.
     * @constructor
     */
    function JSONParser() {
        
        // Super
        psd.framework.Parser.call(this);

        /**
         * className psd.framework.parser.JSONParser
         */
        this.className = "psd.framework.parser.JSONParser";        
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                           INTERNALS                                //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                              API                                   //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

        /**
         * Convierte los datos recibidos en un objeto de js
         * @param data Los datos recibidos
         * @return Un ParserResult con el resultado del parseo
         */
        this.parse = function(data) 
        {
            var parserResult = new psd.framework.ParserResult(psd.framework.ParserResult.PARSER_ERROR_CODE
                                                        , psd.framework.ParserResult.PARSER_ERROR
                                                        , data);
                                                        
            if(typeof(JSON)!="undefined" && typeof(JSON.parse)!="undefined") {
                try {
                    if(typeof(data)=="object")
                        parserResult.result = data;
                    else
                        parserResult.result = JSON.parse(data);

                    parserResult.code = psd.framework.ParserResult.PARSER_SUCCESS_CODE;
                    parserResult.msg = psd.framework.ParserResult.PARSER_SUCCESS;
                }catch(err){ parserResult.msg = err.message; }
            }
            
            return parserResult;
        };
    }
	
    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.JSONParser = JSONParser;

}(psd.framework.parser));(function(namespace) {
	
    // Constantes
    ParserResult.PARSER_SUCCESS_CODE = 0;
    ParserResult.PARSER_ERROR_CODE = 1;
    
    ParserResult.PARSER_SUCCESS = "parser_success";
    ParserResult.PARSER_ERROR = "parser_error";
    
    /**
     * ParserResult es la clase general que encapsula el resultado generado por
     * un Parser
     * @param code Codigo del resultado del parseo
     * @param msg Mensaje del resultado del parseo
     * @param parserResult Resultado del parseo
     * @constructor
     */
    function ParserResult(code, msg, parserResult) 
    {
        this.code = code;
        this.msg = msg;
        this.result = parserResult;
    }
	
    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.ParserResult = ParserResult;

}(psd.framework));(function(namespace) {
	
	ObjectUtil.merge = function(obj1, obj2) {
            var obj3 = {};
            for (var attrName in obj1) { obj3[attrName] = obj1[attrName]; }
            for (var attrName in obj2) { obj3[attrName] = obj2[attrName]; }
            return obj3;
	}
        
	function ObjectUtil() {}

	// Add context window
	namespace.ObjectUtil = ObjectUtil;

}(psd.framework));(function(namespace) {
	
	StringUtil.trim = function trim(str) {
		return str.replace(/^\s+/g,'').replace(/\s+$/g,'');
	};
		
	function StringUtil() {}

	// Add context window
	namespace.StringUtil = StringUtil;

}(psd.framework));(function(namespace) {

    // Inheritance class
    Timer.prototype = new psd.framework.EventDispatcher();

    /**
     * Timer es una clase que permite ejecutar código siguiendo una determinada
     * secuencia temporal
     * @constructor
     */
    function Timer(delay, repeatCount) 
    {
        // Super
        psd.framework.EventDispatcher.call(this);
        
        /**
         * className psd.framework.utils.Timer
         */
        this.className = "psd.framework.utils.Timer";
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                           INTERNALS                                //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        
        // ID de la actual llamada setInterval
        var _intervalID = null;
        
        // Callback para los eventos de setinterval
        var _deferredIntervalCallback = (function(timer) {return function() {_intervalCallback.apply(timer);}})(this);
        var _intervalCallback = function()
        {
            _currentCount++;
            this.dispatchEvent(new psd.framework.events.TimerEvent(psd.framework.events.TimerEvent.TIMER));
            if(_repeatCount != 0)
            {
                if(_repeatCount == _currentCount)
                {
                    this.reset();
                    this.dispatchEvent(new psd.framework.events.TimerEvent(psd.framework.events.TimerEvent.TIMER_COMPLETE));
                }
            }
        };
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                              API                                   //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        
        /**
         * Número de veces que el timer se ha disparado desde que se inició
         */
        var _currentCount = 0;
        this.currentCount = function() { return _currentCount; };
        
        /**
         * El retardo, en milisegundos, entre eventos del timer
         */
        var _delay = delay!=undefined?delay:1000;
        this.delay = function(value)
        {
            if(value!=undefined && value>0) { _delay = value; }
            return _delay;
        };
        
        /**
         * El número total de repeticiones que debe ejecutarse el timer
         */
        var _repeatCount = repeatCount!=undefined?repeatCount:0;
        this.repeatCount = function(value)
        {
            if(value!=undefined && value>0) { _repeatCount = value; }
            return _repeatCount;
        };
        
        /**
         * El estado actual del timer.
         */
        var _running = false;
        this.running = function() { return _running; };
        
        /**
         * Ejecuta el timer si no está en marcha
         */
        this.start = function()
        {
            if(!_running)
            {
                _intervalID = setInterval(_deferredIntervalCallback, _delay);
                _running = true;
            }
        };
        
        /**
         * Detiene el timer
         */
        this.stop = function()
        {
            if(_running)
            {
                clearInterval(_intervalID);
                _running = false;
            }
        };
        
        /**
         * Detiene el timer si está en marcha y resetea la propiedad currentCount a 0
         */
        this.reset = function()
        {
            this.stop();
            _currentCount = 0;
        };
    }
	
    // Incluimos la declaracion de la clase en el namespace psd.framework.utils
    namespace.Timer = Timer;
	
}(psd.framework.utils));(function(window) 
{
    // Generacion del namespace psd.framework
    if(window.psd==undefined) { window.psd = {}; }
    if(window.psd.statistics==undefined) { window.psd.statistics = {}; }
    if(window.psd.statistics.plugins==undefined) { window.psd.statistics.plugins = {}; }
    
    window.psd.statistics.debug = false;
    
    if(window.location.href.indexOf("debug")!=-1) { window.psd.statistics.debug = true; }
    
})(window);(function(namespace) {

    // Inheritance class
    StatisticsManager.prototype = new psd.framework.EventDispatcher();

    /**
     * StatisticsManager es un gestor de estadísticas que permite centralizar
     * las opciones de seguimiento estadístico de una aplicación a través de
     * diferentes plugins y suites estadísticas mediante el uso de ficheros de
     * configuración y una API pública sencilla
     */
    function StatisticsManager() 
    {
		PRUEBAHEAP = 0;

        // Super
        psd.framework.EventDispatcher.call(this);

        /**
         * className psd.statistics.StatisticsManager
         */
        this.className = "psd.statistics.StatisticsManager";        
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                           INTERNALS                                //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        
        // Array de plugins registrados
        var _plugins = {length:0};
		var _currentPlugin;
        
        // Objeto de datos generales
        var _data = {};

		//Objeto de datos obligatorios
		var _pendingHeap = [];
		var _pending = null;
		var _currentTry = 0;

		_dataDynamic = [];
        
        // Objeto con las reglas de enrutamiento de eventos
        var _routing = {};
        
        // Controla si el manager ha completado la carga de las opciones de 
        // configuración y ha terminado de inicializarse
        var _initialized = false;
        
        // Lista de suscriptores de eventos
        var _subscribersList = [];
        
        // Utilidad para obtener la declaración de una clase a partir de su
        // nombre completo (paquete incluido)
        // @param className El nombre completo de la clase
        // @return La clase solicitada si se encuentra, window si no.
        var _getClass = function(className)
        {
            var namespaces = className.split("."),
                numNamespaces = namespaces.length, i,
                skinClass = (window || this);
                
            for(i=0;i<numNamespaces;i++) {skinClass = skinClass[namespaces[i]];}
                
            return skinClass;
        };
        
        // Importa la configuración del manager a partir de un objeto de configuración.
        // El objeto de configuración debe tener la siguiente estructura:
        //  OBJ
        //   |- config
        //        |---- [data] (Array)  
        //                 |--------------- {name, value}
        //        |---- [plugins] (Array)
        //                 |--------------- {id, type, url}
        //        |---- [routing] (Array)
        //                 |--------------- {name, type, plugins}
        //                 
        // @param settings Objeto con la configuración que se quiere transferir.
        var _importObjectConfiguration = function(settings) {
            
            // Comprobamos que existe la propiedad principal "config"
            if(typeof(settings.config)!="undefined")
            {
                var data    = settings.config.data,
                    plugins = settings.config.plugins,
                    routing = settings.config.routing,
                    i, length;
                			
                // Utilizamos la API pública setData() para importar
                // los datos de caracter general
                if(Object.prototype.toString.call(data)=="[object Array]"){
                    
                    for(i=0;i<data.length;i++) {
                        if(typeof(data[i])!="undefined" &&
                           typeof(data[i].name)!="undefined" &&
                           typeof(data[i].value)!="undefined") {
                           
                           this.setData(data[i].name, data[i].value);
                        }
                    }
                }
                
                // Utilizamos la API pública loadPlugin() para importar e
                // inicializar los plugins especificados en la configuración
                if(Object.prototype.toString.call(plugins)=="[object Array]"){
                    
                    for(i=0;i<plugins.length;i++) {
                        if(typeof(plugins[i])!="undefined" &&
                           typeof(plugins[i].id)!="undefined" &&
                           typeof(plugins[i].type)!="undefined") {
                           
                            if(typeof(plugins[i].url)!="undefined"){
                                this.loadPlugin(plugins[i].id, plugins[i].type, plugins[i].url);
                            } else {
                                this.loadPlugin(plugins[i].id, plugins[i].type, plugins[i].config);
                            }
                        }
                    }
                }
                
                // Utilizamos la API pública addRouting() para importar las reglas
                // de enrutamiento especificadas en la configuración
                if(Object.prototype.toString.call(routing)=="[object Array]"){
                    
                    for(i=0;i<routing.length;i++) {
                        if(typeof(routing[i])!="undefined" &&
                           typeof(routing[i].name)!="undefined" &&
                           typeof(routing[i].plugins)!="undefined" &&
                           typeof(routing[i].type)!="undefined") {
                           
                           this.addRouting(routing[i].name, routing[i].type, routing[i].plugins);
                        }
                    }
                }
                
                // Indicamos que el manager se ha inicializado
                _initialized = true;
                
                // Si tenemos subscribers en la lista, generamos los eventlisteners
                // apropiados para ellos
                length = _subscribersList.length;
                for(i=0;i<length;i++) {
                    _addListeners.apply(this, [_subscribersList[i].subscriber]);
                }
            }
        };
        
        // Añade los listeners especificados por las reglas de enrutamiento a 
        // un objeto emisor
        var _addListeners = function(emitter) {
            var routing = this.getRouting(),
                i;
            
            for(i in routing) {
                emitter.addEventListener(i, _deferredOnEmitterEvent);
            }
        }
        
        // Elimina los listeners especificados por las reglas de enrutamiento de 
        // un objeto emisor
        // var _removeListeners = function(emitter) {
        //    var routing = this.getRouting(),
        //        i;
        //    
        //    for(i in routing) {
        //        emitter.removeEventListener(i, _deferredOnEmitterEvent);
        //    }
        // }
        
        // Carga la configuración del manager a partir de un objeto de configuración
        // remoto. El fichero de configuración debe estar en formato JSON y tener la 
        // siguiente estructura:
        //{
        //    "config":{
        //        "data": [
        //            {"name": "unidadDeNegocio", "value": "40TV"},
        //            {"name": "nombreCanal", "value": "Los 40TV"}
        //        ],
        //        "plugins": [
        //            {	"id": "omniture",
        //                "c",
        //                "url": "conf/players/psd_player/plugins/omniture.xml"
        //            }            
        //        ],
        //        "routing": [
        //            {"name": "mediaBegin", "plugins": "omniture", "type":"custom"},
        //            {"name": "mediaComplete", "plugins": "omniture", "type":"custom"},
        //            {"name": "mediaHalf", "plugins": "omniture", "type":"custom"}
        //        ]
        //    }
        //}
        // @param url URL con la dirección del fichero de configuración.
        var _importRemoteConfiguration = function(url) {
            _configMediator.corsIE(true);
            _configMediator.mediate(url, _configParser, psd.framework.Mediator.RESPONSE_JSON);            
        };

        // Fusiona dos listas de datos, uno de evento y otro general en un único
        // listado, añadiendo un prefijo "data." o "global." a cada dato en
        // función de su origen.
        // @param data Datos particulares del evento marcado
        // @param global Datos de carácter general o global
        var _merge = function(data, global) {
            var consolidated = {},
                i;
            
            // Los datos de evento se prefijan con "data."
            for(i in data) {consolidated["data."+i] = data[i];}
            
            // Los datos generales se prefijan con "global."
            for(i in global) {consolidated["global."+i] = global[i];}
            
            return consolidated;
        }
        
        // Listener que escucha el evento MEDIATE_COMPLETE del mediator del
        // fichero de configuración del manager
        // @param evt El evento de tipo MEDIATE_COMPLETE disparado
        var _onMediatorComplete = function(evt) {
            var parserResult = evt.result.parserResult;
            
            if(parserResult.code == psd.framework.ParserResult.PARSER_SUCCESS_CODE) {
                _importObjectConfiguration.apply(this, [parserResult.result]);
            }else {
                // TO-DO GESTIÓN DEL ERROR DE PARSEO
                console.log("PARSER ERROR");
                console.log(parserResult.msg);
            }
        };
        
        // Listener que escucha el evento MEDIATE_ERROR del mediator del
        // fichero de configuración del manager
        // @param evt El evento de tipo MEDIATE_ERROR disparado
        var _onMediatorError = function(evt) {
            // TO-DO GESTIÓN DEL ERROR DE LECTURA
            console.log("MEDIATE ERROR");
            console.log(evt.result.msg);
        };
        
        // Mediator para la carga de ficheros de configuración
        var _configMediator = new psd.framework.Mediator();
            _configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_COMPLETE, _onMediatorComplete, this);
            _configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_ERROR, _onMediatorError, this);
        
        // Parser para la carga de ficheros de configuración
        var _configParser = new psd.framework.parser.JSONParser();
        
        // Listener que escucha eventos de los emisores registrados en el manager
        // para el modo de seguimiento automático
        // @param evt El evento de seguimiento
        var _deferredOnEmitterEvent = (function(statisticsManager){return function(evt){_onEmitterEvent.apply(statisticsManager,[evt]);}})(this);
        var _onEmitterEvent = function(evt) {
            
            var subscriber = evt.target,
                pattern = _getSubscriberPattern.apply(this, [subscriber]),
                patternType,
                data = evt.data;
            
            // Si tenemos un patrón de conversión asociado al evento recibido,
            // obtenemos la información del evento a partir del patrón
            if( pattern != null) {
                
                patternType = Object.prototype.toString.call(pattern);
                
                if(patternType == "[object String]") {
                    data = subscriber[pattern];
                }else if (patternType == "[object Function]") {
                    data = pattern.apply(subscriber, [evt]);
                }else if (patternType == "[object Array]") {
                    // TO-DO Resolver un array de variables
                }
            }
            
            // Utilizamos la API pública track() para realizar el seguimiento
            // del evento de manera automática

            this.track(evt.type, data);
        };
        
        // Localiza el patrón de conversión de variables de evento
        var _getSubscriberPattern = function (subscriber) {
            var i, pattern = null,
                subscribersLength = _subscribersList.length;
            
            if(typeof(subscriber)!="undefined" && subscriber!=null) { 
                for(i=0;i<subscribersLength;i++) {
                    if(_subscribersList[i].subscriber === subscriber) {
                        pattern = _subscribersList[i].subscriptionPattern;
                        break;
                    }
                }
            }
            
            return pattern;
        }

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                              API                                   //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        
        /**
         * Importa la configuración de un fichero remoto o un objeto local
         * @param settings String con la url a un json de configuración o un 
         *                 objeto de configuración 
         */
        this.setup = function(settings) {

            var configType = Object.prototype.toString.call(settings);
            
            // Iniciamos la carga remota si el parámetro es un String, o la carga
            // local si el parámetro es un Object
            if(configType == "[object String]") {
                _importRemoteConfiguration.apply(this, [settings]);

                console.log("Setup: El objeto es un String = "+configType)//*Jacob

            }else if(configType == "[object Object]") {
                _importObjectConfiguration.apply(this, [settings]);

                console.log("Setup: El objeto es un Object ="+configType)//*Jacob
            }
        };
        
        /**
         *  Array de plugins de estadísticas registrados
         */
        this.getPlugins = function() { return _plugins;


        };
        
        /**
         * Obtiene un plugin de estadísticas registrado
         * @param id El id del plugin de estadísticas
         */
        this.getPlugin = function(id) {return _plugins[id];}; 
        
        /**
         * Registra un plugin de estadísticas existente
         * @param id El id del plugin de estadísticas
         * @param plugin El plugin de estadísticas
         */
        this.addPlugin = function(id, plugin) {
            if (typeof(_plugins[id])==="undefined") {_plugins.length++;}
            _plugins[id] = plugin;

            console.log(_plugins);//*Jacob
        };
        
        /**
         * Registra un nuevo plugin de estadísticas, creándolo a partir de 
         * su clase e inicializándolo con la configuración de entrada
         * @param id El id del plugin de estadísticas
         * @param className La clase del plugin de estadísticas
         * @param conf Las opciones de configuración para la inicialización
         *              del plugin
         */
        this.loadPlugin = function(id, className, conf) {

            var pluginClass = _getClass(className),
                plugin = new pluginClass();
                plugin.setup(conf);
                plugin.setDataProfile(_data);
				
            this.addPlugin(id, plugin);
        };
        
        /**
         * Elimina un plugin de la lista de plugins registrados
         * @param id El id del plugin que se quiere des-registar
         */
        this.removePlugin = function(id) {
            if (typeof(_plugins[id])!=="undefined") { 
                _plugins.length--;
                delete _plugins[id];
            }
        };
        
        /**
         * Elimina una serie de plugins de la lista de plugins registrados
         * @param pluginsList Array con los ids de los plugins que se quieren 
         *                      des-registrar. Si no se recibe pluginsList, se
         *                      eliminarán todos los plugins existentes
         */
        this.removePlugins = function(pluginsList) {
            var i;
            if(typeof(pluginsList)==="undefined")
            {
                for(i in _plugins){if(i!=="length") this.removePlugin(i);}
            } else {for(i in pluginsList) {this.removePlugin(pluginsList[i]);}}
        };
        
        /**
         * Activa un plugin para el registro de estadísticas
         * @param id El id del plugin que se quiere activar
         */
        this.enablePlugin = function(id) {
            if (typeof(_plugins[id])!=="undefined") { 
                _plugins[id].enable();
            }
        };
        
        /**
         * Activa una serie de plugins para el registro de estadísticas
         * @param pluginsList Array con los ids de los plugins que se quieren 
         *                      activar. Si no se recibe pluginsList, se
         *                      activarán todos los plugins existentes
         */
        this.enablePlugins = function(pluginsList) {
            var i;
            if(typeof(pluginsList)==="undefined")
            {
                for(i in _plugins){if(i!=="length") this.enablePlugin(i);}
            } else {for(i in pluginsList) {this.enablePlugin(pluginsList[i]);}}
        };
        
        /**
         * Desactiva un plugin para el registro de estadísticas
         * @param id El id del plugin que se quiere desactivar
         */
        this.disablePlugin = function(id) {
            if (typeof(_plugins[id])!=="undefined") { 
                _plugins[id].disable();
            }        
        };
        
        /**
         * Desactiva una serie de plugins para el registro de estadísticas
         * @param pluginsList Array con los ids de los plugins que se quieren 
         *                      desactivar. Si no se recibe pluginsList, se
         *                      desactivarán todos los plugins existentes
         */
        this.disablePlugins = function(pluginsList) {
            var i;
            if(typeof(pluginsList)==="undefined")
            {
                for(i in _plugins){if(i!=="length") {this.disablePlugin(i);}}
            } else {for(i in pluginsList) {this.disablePlugin(pluginsList[i]);}}
        };
        
        /**
         * Obtiene un valor de carácter general
         * @param key El id del valor que se quiere consultar. Si no se recibe key,
         *              se devuelve el array completo de datos
         */
        this.getData = function(key) {
            if(typeof(key)=="undefined"){return _data;}
            if(typeof(_data[key])=="undefined") {return null;}
            else {return _data[key];}
        };
        
        /**
         * Crea o actualiza un dato de carácter general
         * @param key El identificador del valor que se quiere crear o modificar
         * @param value El valor que se quiere asignar al dato
         */
        this.setData = function(key, value) {_data[key] = value;};
        

		this.setDataDynamic = function(dataDynamic) {

		for(i in dataDynamic){
				for(j in this._dataDynamic){
					if(this._dataDynamic[j].name==dataDynamic[i].name)
					{
		                this._dataDynamic[j] = {"name" : dataDynamic[i].name, "value" : dataDynamic[i].value};
					}
				}
			}

			if(_currentTry>5){
				_pending = null;
			}
			if(_pending==null)
			{
				if(_pendingHeap.length>0)
				{
					_currentTry = 0;

                    _pending = _pendingHeap[0];
                    _pendingHeap.splice(0,1);

                    this.multitrack(_pending.rule,_pending.data,_pending.plugin);
				}
			}
			else{
                this.multitrack(_pending.rule,_pending.data,_pending.plugin);
			}
		}

        /**
         * Elimina un dato de carácter general
         * @param key El identificador del dato que se quiere eliminar
         */
        this.unsetData = function(key) {delete _data[key];};
        
        /**
         * Obtiene una regla de enrutamiento
         * @param rule El nombre de la regla que se quiere consultar. Si no se 
         *              recibe rule, se devuelve el array completo de enrutamientos
         */
        this.getRouting = function(rule) {
            if(typeof(rule)=="undefined"){return _routing;}
            if(typeof(_routing[rule])=="undefined") {return null;}
            else {return _routing[rule];}
        };
        
        /**
         * Crea o actualiza una regla de enrutamiento
         * @param rule Identificador de la regla de enrutamiento
         * @param type Tipo de seguimiento a realizar asociado al enrutamiento
         * @param plugins Plugins que se deben notificar cuando se active la regla
         */
        this.addRouting = function(rule, type, plugins) {
            _routing[rule] = {type:type, plugins:plugins};
        };
        
        /**
         * Realiza el seguimiento de un evento en la aplicación
         * @param rule El evento que se ha producido
         * @param data Datos relacionados con el evento
         */
        this.track = function(rule, data) {
            var routing = this.getRouting(rule),
                consolidatedData = _merge(data, _data),
                routes, routesLength, i, plugin;
            
            // Analizamos si tenemos reglas de enrutamiento que aplicara
            if(routing){

				auxDynamics = [];

                routes = routing.plugins.split(",");
                routesLength = routes.length;
                for(i=0;i<routesLength;i++){
                    plugin = this.getPlugin(routes[i]);
                    if(plugin) {
						this._dataDynamic = plugin._dataDynamic;
						this.multitrack(rule, data, plugin);
                    }
                }
            }
        };

		this.multitrack = function(rule, data, plugin){
		
			_currentTry++;

			var routing = this.getRouting(rule);
            var consolidatedData = _merge(data, _data);

 	        	if(this.hasAllDynData()){
				
	            	plugin.track(rule, routing.type, consolidatedData);
	                _pending = null;
	                _currentTry = 0;

                    for(i in this._dataDynamic){
                        this._dataDynamic[i].value = "";
                    }


                    if(plugin.setDataDynamic!=undefined)
                        plugin.setDataDynamic(this._dataDynamic);

					if(_pendingHeap.length>0)
					{
						_pending = _pendingHeap[0];
						_pendingHeap.splice(0,1);

						this.multitrack(_pending.rule,_pending.data,_pending.plugin);
					}
	           	}
	            else{
	            	if(_pending==null){
	                	_pending =  {   "rule":rule,
	                                    "data":data,
										"plugin":plugin
	                                };
	                }else{
	               }
	               this.dispatchEvent(new psd.statistics.StatEvent(psd.statistics.StatEvent.DATA_REQUIRED,this._dataDynamic,_data,plugin));
       		}
		}

        this.hasAllDynData = function() {

            allRequired = true;

            for(i in this._dataDynamic){
                if(this._dataDynamic[i].value == ""){
                    allRequired = false;
				}
            }

			return allRequired;
		}
           
        
        /**
         * Suscribe un elemento para el seguimiento estadístico automático
         * @param emitter El elemento emisor de eventos que sirve para el seguimiento
         * @param pattern Patrón que se debe aplicar para la conversión de los datos
         *                  del evento cuando se produce
         */
        this.subscribe = function(emitter, pattern) {
            _subscribersList.push({ subscriber: emitter, 
                                    subscriptionPattern: pattern||{}
                                    });
            
            if(_initialized) { _addListeners.apply(this,[emitter]); }
        };
        
        // this.unsubscribe = function() {
        //    for(var i in _subscribersList) {
        //        _removeListeners.apply(this,[_subscribersList[i].subscriber]);
        //    }
        // }
    }
    
    // Incluimos la declaracion de la clase en el namespace psd.statistics
    namespace.StatisticsManager = StatisticsManager;

})(psd.statistics);
(function(namespace) {

    // Inheritance class
    TrackingPlugin.prototype = new psd.framework.EventDispatcher();

    /**
     * TrackingPlugin es la base para los plugins del sistema de estadísticas
     * multimedia
     */
    function TrackingPlugin() 
    {
        // Super
        psd.framework.EventDispatcher.call(this);

        /**
         * className psd.statistics.TrackingPlugin
         */
        this.className = "psd.statistics.TrackingPlugin";        
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                           INTERNALS                                //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                              API                                   //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        
		var _dataProfile = [];
		
        /**
         * Activa el plugin para el envío de estadísticas
         */
        this.enable = function() { _enabled = true; };
        
        /**
         * Desactiva el plugin para el envío de estadísticas
         */
        this.disable = function() { _enabled = false; };
        
        /**
         * Indica si el plugin está activado o no para el envío de estadísticas
         */
        var _enabled = true;        
        this.enabled = function() { return _enabled; };
        
        /**
         * Añade un nuevo mapeo de datos entre los recibidos para el seguimiento
         * y los realmente enviados
         */
        this.addDataMapping = function(name, value) { 
			if(this._dataProfile[value.replace("data.","")]!=undefined){
				_dataMap[name] = this._dataProfile[value.replace("data.","")]; 
			}
			else
				_dataMap[name] = value; 
		};
		
		this.setDataProfile = function(dp){
			this._dataProfile = dp;
		}
        
        /**
         * Mapa de correspondencias entre los datos recibidos y los que se deben
         * enviar 
         */
        var _dataMap = {};        
        this.dataMap = function() { return _dataMap; };

		this._dataDynamic = [];

        this.loadDynamics = function(_settings){
			if(_settings.config.dataMapping!=undefined){
	            for(i in _settings.config.dataMapping){
					_name = _settings.config.dataMapping[i].name;
	                _value = _settings.config.dataMapping[i].value;

	                if(_value.indexOf("datadyn.")>-1){
	                    this._dataDynamic.push({"name":_name,"value":""});
	                }
	            }
	        }
		}


        this.setDataDynamic = function(dataDynamic){
            this._dataDynamic = dataDynamic;
        }

        this.clearDataDynamic = function(){
            for(i in this._dataDynamic){
                this._dataDynamic[i].value = "";
            }
        }
    }
    
    // Incluimos la declaracion de la clase en el namespace psd.statistics
    namespace.TrackingPlugin = TrackingPlugin;

})(psd.statistics);
(function(namespace) {

    // Inheritance class
    OmniturePlugin.prototype = new psd.statistics.TrackingPlugin();

    // Construct
    function OmniturePlugin() 
    {
        // Super
        psd.statistics.TrackingPlugin.call(this);

        /**
         * className psd.statistics.OmniturePlugin
         */
        this.className = "psd.statistics.OmniturePlugin";        
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                           INTERNALS                                //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        
        // Mapa de eventos que gestiona el plugin
        var _eventMappings = {};
                
        // Importa la configuración del plugin a partir de un objeto de configuración.
        // El objeto de configuración debe tener la siguiente estructura:
        //  OBJ
        //   |- config
        //        |---- [events] (Array)  
        //                 |--------------- {name, events, vars, suites}
        //        |---- [dataMapping] (Array)
        //                 |--------------- {name, value}
        //                 
        // @param settings Objeto con la configuración que se quiere transferir.
        var _importObjectConfiguration = function(settings) {
            
			this.loadDynamics(settings);


            // Comprobamos que existe la propiedad principal "config"
            if(typeof(settings.config)!="undefined")
            {            
                var events  = settings.config.events,
                    mapping = settings.config.dataMapping,
                    i, length;
                    
                // Utilizamos la API pública addEventMapping() para importar
                // las definiciones de mapeo de eventos
                if(Object.prototype.toString.call(events)=="[object Array]"){

                    for(i=0;i<events.length;i++) {
                        if(typeof(events[i])!="undefined" &&
                            typeof(events[i].name)!="undefined" &&
                            typeof(events[i].events)!="undefined" &&
                            typeof(events[i].vars)!="undefined" &&
                            typeof(events[i].suites)!="undefined") {

                            this.addEventMapping(events[i].name, 
                                                events[i].events,
                                                events[i].vars,
                                                events[i].suites);
                        }
                    }
                }
                
                // Utilizamos la API pública addDataMapping() para importar
                // las definiciones de mapeo de datos
                if(Object.prototype.toString.call(mapping)=="[object Array]"){

                    for(i=0;i<mapping.length;i++) {
                        if(typeof(mapping[i])!="undefined" &&
                            typeof(mapping[i].name)!="undefined" &&
                            typeof(mapping[i].value)!="undefined") {

                            this.addDataMapping(mapping[i].name, 
                                                mapping[i].value);
                        }
                    }
                }
            }
        };
        
        // Carga la configuración del plugin a partir de un objeto de configuración
        // remoto. El fichero de configuración debe estar en formato JSON y tener la 
        // siguiente estructura:
        //{
        //    "config":{
        //        "events": [
        //            {   
        //                "name": "mediaBegin", 
        //                "events": "event11", 
        //                "vars": "eVar2,eVar3,eVar4,eVar8,eVar17,eVar20,eVar30,eVar35,eVar42,eVar48,eVar74", 
        //                "suites": "prisacomaspreprod,suite_producto"            
        //            },{ 
        //                "name": "mediaComplete", 
        //                "events": "event12", 
        //                "vars": "eVar2,eVar3,eVar4,eVar8,eVar17,eVar20,eVar30,eVar35,eVar42,eVar48,eVar74", 
        //                "suites": "prisacomaspreprod,suite_producto"
        //            }
        //        ],
        //        "dataMapping": [
        //            {"name": "eVar8", "value": "data.name" },
        //            {"name": "eVar9", "value": "data.adName" },
        //            {"name": "eVar74", "value": "data.duration" }
        //        ]
        //    }
        //}
        // @param url URL con la dirección del fichero de configuración.
        var _importRemoteConfiguration = function(url) {
            _configMediator.corsIE(true);
            _configMediator.mediate(url, _configParser, psd.framework.Mediator.RESPONSE_JSON);            
        };
        
        // Listener que escucha el evento MEDIATE_COMPLETE del mediator del
        // fichero de configuración del manager
        // @param evt El evento de tipo MEDIATE_COMPLETE disparado
        var _onMediatorComplete = function(evt) {
            var parserResult = evt.result.parserResult;
            
            if(parserResult.code == psd.framework.ParserResult.PARSER_SUCCESS_CODE) {
                _importObjectConfiguration.apply(this, [parserResult.result]);
            }else {
                // TO-DO GESTIÓN DEL ERROR DE PARSEO
                console.log("PARSER ERROR");
                console.log(parserResult.msg);
            }
        };
        
        // Listener que escucha el evento MEDIATE_ERROR del mediator del
        // fichero de configuración del manager
        // @param evt El evento de tipo MEDIATE_ERROR disparado
        var _onMediatorError = function(evt) {
            // TO-DO GESTIÓN DEL ERROR DE LECTURA
            console.log("MEDIATE ERROR");
            console.log(evt.result.msg);
        };
        
        // Mediator para la carga de ficheros de configuración
        var _configMediator = new psd.framework.Mediator();
            _configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_COMPLETE, _onMediatorComplete, this);
            _configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_ERROR, _onMediatorError, this);
        
        // Parser para la carga de ficheros de configuración
        var _configParser = new psd.framework.parser.JSONParser();        
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                              API                                   //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        
        /**
         * Importa la configuración de un fichero remoto o un objeto local
         * @param settings String con la url a un json de configuración o un 
         *                 objeto de configuración 
         */
        this.setup = function(settings) {
            
            var settingsType = Object.prototype.toString.call(settings);
            
            // Iniciamos la carga remota si el parámetro es un String, o la carga
            // local si e
            // l parámetro es un Object
            if(settingsType=="[object String]") {
                _importRemoteConfiguration.apply(this, [settings]);
            } else if(settingsType=="[object Object]") {
                _importObjectConfiguration.apply(this, [settings]);
            }
			
			
			if((typeof(s)==="undefined") && (typeof(s_gi)!=="undefined"))
				s = s_gi("");
        };
        
        /**
         * Realiza el seguimiento de un evento en la aplicación
         * @param event El evento que se ha producido
         * @param type El modo de marcado que se debe utilizar para el evento. Por
         *              lo general será "custom", pero también se pueden esperar
         *              modos como "media" o "properties"
         * @param data Datos relacionados con el evento y de carácter general
         * TO-DO Utilizar "type" para seleccionar el tipo de seguimiento que
         * se hace: custom, Media,...
         */
        this.track = function(event, type, data) {
			if(typeof(window.s)=="undefined"){
				return;
			}

            var dataMap = this.dataMap(),
                eventMap = _eventMappings[event],
                trackVars, trackEvents,
                previousTrackVars = s.linkTrackVars, 
                previousTrackEvents = s.linkTrackEvents,
                previousEvents = s.events,
                previousVisitorNamespace = s.visitorNamespace,
                previousUsePlugins = s.usePlugins,
                previousS = s,
                previousTrackSuites = null,
                i;

            if(s.account!=undefined)
                previousTrackSuites = s.account;
            else
                previousTrackSuites = s_account;


            // Realizamos el seguimiento únicamente si tenemos un eventMap definido
            if(typeof(eventMap)!="undefined")
            {

                s = s_gi(eventMap.suites);
                s.linkTrackVars = "";
                s.linkTrackEvents = "";
                s.events = "";
                s.usePlugins = false;
                s.visitorNamespace = previousVisitorNamespace;
                
                // Copiamos las antiguas eVars
/*
                var idProp;
                for(i in previousS) {
                    if(i.indexOf("eVar")==0) {
                        s[i] = previousS[i];
                    }
                }
*/
                 // Copiamos las antiguas eVars y hacemos la traducción de alias a su valor dinámico
                var idProp;
                for(i in previousS) {
                    if(i.indexOf("eVar")==0) {
                        if (previousS[i]!=undefined && previousS[i].indexOf("D=c") == 0) {
                            idProp = previousS[i].substring(3);
                            s[i] = previousS["prop" + idProp];
                        }else {
                            s[i] = previousS[i];
                        }
                    }
                }

                // Conversión de evento a events en la suite de omniture
                trackEvents = eventMap.events;
                if(eventMap.events.length>0) {
                    s.linkTrackVars += "events";
                    
                    for(i in trackEvents) {
                        s.linkTrackEvents += "," + trackEvents[i];
                        s.events += "," + trackEvents[i];
                    }
                }
                
                for(i in this._dataDynamic){
                    dataMap[this._dataDynamic[i].name] = this._dataDynamic[i].value;
                    data[this._dataDynamic[i].name] = "data." + this._dataDynamic[i].value;
                }

                // Conversión de datos a variables en la suite de omniture
                trackVars = eventMap.vars;
                for(i in trackVars) {
                    
                    s.linkTrackVars += "," + trackVars[i];

                    if(typeof(dataMap[trackVars[i]])!="undefined") {
                        if(typeof(data[dataMap[trackVars[i]]])!="undefined") {
                            s[trackVars[i]] = (typeof(data[dataMap[trackVars[i]]]) == "string")?data[dataMap[trackVars[i]]].toLowerCase():data[dataMap[trackVars[i]]]; 
                        } else {
                            s[trackVars[i]] = ""; //Si no hay valor mandamos un blanco
                            //s[trackVars[i]] = dataMap[trackVars[i]].toLowerCase();
                        }
                    }
                }
			
                if(s.linkTrackEvents.indexOf(",")==0) {s.linkTrackEvents = s.linkTrackEvents.substr(1);}
                if(s.linkTrackVars.indexOf(",")==0) {s.linkTrackVars = s.linkTrackVars.substr(1);}


                //Traducción de ALIAS en s_code
               /* var idProp;
                for(i in s) {
                    if((i.indexOf("eVar")==0) &&  (s[i].indexOf("D=c") == 0)){
                        idProp = s[i].substring(3);
                        s[i] = previousS["prop" + idProp];
                    }
                }*/


                s.tl(true, 'o', event);

                // Deshacemos los cambios realizados sobre las variables de Omniture
                // y eliminamos las variables que hemos creado para el evento
                s.visibleAlias =
                s = s_gi(previousTrackSuites);

                s.linkTrackVars = previousTrackVars;
                s.linkTrackEvents = previousTrackEvents;
                s.events = previousEvents;
                s.usePlugins = previousUsePlugins;
	
                for(i in trackVars) {
                                        
                    if(typeof(dataMap[trackVars[i]])!="undefined" && 
                        typeof(data[dataMap[trackVars[i]]])!="undefined") {
                        
                        delete s[trackVars[i]];
                        
                    }
                }             
            }
        };
        
        /**
         * Crea una nueva regla de mapeo para un evento
         * @param name Nombre del evento
         * @param events Eventos que se deben registrar en la suite de omniture
         * @param vars Variables que se deben registrar en la suite de omniture
         * @param suites Cuentas en las que se debe registrar la acción
         */
         this.addEventMapping = function(name, events, vars, suites) {
            _eventMappings[name] = {events: events.split(","), vars: vars.split(","), suites:suites};
         };
    }
    
    // Incluimos la declaracion de la clase en el namespace psd.statistics
    namespace.OmniturePlugin = OmniturePlugin;

})(psd.statistics.plugins);(function(namespace) {

    // Inheritance class
    ComscorePlugin.prototype = new psd.statistics.TrackingPlugin();
	
    // Construct
    function ComscorePlugin() 
    {
		// Super
        psd.statistics.TrackingPlugin.call(this);
	
        /**
         * className psd.statistics.OmniturePlugin
         */
        this.className = "psd.statistics.ComscorePlugin";
		
        
		//constantes
		var assocEvents = {	"ON_PLAY" : "onPlay",
							"ON_PAUSE" : "onPause",
							"ON_STOP" : "onStop",
							"ON_AD_PLAY" : "onAdPlay",
							"ON_AD_STOP" : "onAdStop"};
		
		var _streamSense;
		
		var _data = {};
		var settings;
		var settingsUrl;
		
		var _configParser;
		var _configMediator;
		
		var parserResult;		
		
		var _importRemoteConfiguration = function(url) {
            _configMediator.corsIE(true);
            _configMediator.mediate(url, _configParser, psd.framework.Mediator.RESPONSE_JSON);
        };
		
		// Listener que escucha el evento MEDIATE_ERROR del mediator del
        // fichero de configuraci�n del manager
        // @param evt El evento de tipo MEDIATE_ERROR disparado
        var _onMediatorError = function(evt) {
            // TO-DO GESTI�N DEL ERROR DE LECTURA
            //console.log("MEDIATE ERROR");
            //console.log(evt.result.msg);
        };
		
		// Listener que escucha el evento MEDIATE_COMPLETE del mediator del
        // fichero de configuraci�n del manager
        // @param evt El evento de tipo MEDIATE_COMPLETE disparado
        var _onMediatorComplete = function(evt) {
            parserResult = evt.result.parserResult;            
			
            if(parserResult.code == psd.framework.ParserResult.PARSER_SUCCESS_CODE) {
                _importObjectConfiguration.apply(this, [parserResult.result]);
            }else {
                // TO-DO GESTI�N DEL ERROR DE PARSEO
                console.log("PARSER ERROR");
                console.log(parserResult.msg);
            }
        };
		
		var _importObjectConfiguration = function(_settings) {
				
			settings = _settings;
		
			this.loadDynamics(settings);
		
            if(typeof(settings.config)!="undefined")
            {   	
				_streamSense = new ns_.StreamSense({},settings.config.pixelURL);
				
				_playlistLabels = {};
				
				for(i in settings.config.dataMappingPlayList){
					_name = settings.config.dataMappingPlayList[i].name;
					_value = settings.config.dataMappingPlayList[i].value;
					
					_playlistLabels[_name] = _value;
				}
				_streamSense.setPlaylist(_playlistLabels);
			}
			
			mapping = settings.config.dataMapping;
			
			if(Object.prototype.toString.call(mapping)=="[object Array]"){

                for(i=0;i<mapping.length;i++) {
					if(typeof(mapping[i])!="undefined" &&
						typeof(mapping[i].name)!="undefined" &&
						typeof(mapping[i].value)!="undefined") {

						this.addDataMapping(mapping[i].name, 
											mapping[i].value);
					}
				}
            }
		}
		
		/**
         * Importa la librer�a libraryManager y al completar la carga se llama a la funci�n que importa la configuraci�n del plugin
         * @param settings String con la url a un json de configuraci�n o un 
         *                 objeto de configuraci�n 
         */
        this.setup = function(settings) {

			settingsUrl = settings;
		
			var dependencesUrls = [];
			dependencesUrls.push("http://www.prisacom.com/psdmedia/resources/js/ext/comscore/streamsense.min.js");
		
			var libraryParams = {depends: dependencesUrls
				, success: onDependencesComplete
				, error: onDependencesError
				, scope: this
			};
			
			LibraryManager.load(libraryParams);
		}
		
		/**
         * Importa la configuraci�n de un fichero remoto o un objeto local
		 */
		var onDependencesComplete = function() 
		{
			_configParser = new psd.framework.parser.JSONParser();
			_configMediator = new psd.framework.Mediator();
			_configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_COMPLETE, _onMediatorComplete, this);       
			_configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_ERROR, _onMediatorError, this);
			
			_importRemoteConfiguration.apply(this, [settingsUrl]);
		}	

		var onDependencesError = function() {
		}
		
		/**
         * Realiza el seguimiento de un evento en la aplicaci�n
         * @param event El evento que se ha producido
         * @param type El modo de marcado que se debe utilizar para el evento. Por
         *              lo general ser� "custom", pero tambi�n se pueden esperar
         *              modos como "media" o "properties"
         * @param data Datos relacionados con el evento y de car�cter general
         * TO-DO Utilizar "type" para seleccionar el tipo de seguimiento que
         * se hace: custom, Media,...
         */
        this.track = function(event, type, data) {
			_data = data;
			
			position = 0;
			labels = {};
			
			profileData = this.dataMap();
			
			for(i in settings.config.dataMapping){

				_name = settings.config.dataMapping[i].name;
				_value = settings.config.dataMapping[i].value;
				
				if(profileData[_name]!=undefined)
					labels[_name] = profileData[_name];
				
				{		
					if(_value.indexOf("data.")>-1){
						valueAux = _value.slice("data.".length,_value.length);
						labels[_name] = data[_value];
						
						if(labels[_name]==undefined){
							labels[_name] = profileData[_name];
						}
					}
					else{
						if(_value == "TITLE"){
							labels[_name] = document.title;
						}
						else{
							if(_value.indexOf("datadyn.")>-1){
								valueAux = _value.slice("datadyn.".length,_value.length);
								labels[_name] = this.getDynValue(valueAux);
							}
							else{
								labels[_name] = _value;
							}
						}
					}
				}
			}
			_streamSense.setClip(labels, 1);
	
			assocEvent = undefined;

			for(i in settings.config.events){
				if(settings.config.events[i].name==event){
					assocEvent = settings.config.events[i].value;
				}
			}

			if(assocEvent!=undefined){
				
				switch(assocEvent){

					case "ON_PLAY":
						_streamSense.notify(ns_.StreamSense.PlayerEvents.PLAY,{"ns_st_ad":false},0);
					break;
					case "ON_PAUSE":
						_streamSense.notify(ns_.StreamSense.PlayerEvents.PAUSE,{"ns_st_ad":false},0);
					break;
					case "ON_STOP":
						_streamSense.notify(ns_.StreamSense.PlayerEvents.END,{"ns_st_ad":false},0);
					break;
					case "ON_AD_PLAY":
						_streamSense.notify(ns_.StreamSense.PlayerEvents.AD_PLAY,{"ns_st_ad":true},0);
					break;
					case "ON_AD_STOP":
						_streamSense.notify(ns_.StreamSense.PlayerEvents.AD_END,{"ns_st_ad":true},0);
					break;
					default:
					break;
				}
			}
		}
	
		this.clearDataDynamic = function(){
			for(i in this._dataDynamic){
				this._dataDynamic[i].value = "";
			}
		}

		this.getDynValue = function(_name){
			for(i in this._dataDynamic){
				if(this._dataDynamic[i].name==_name)
					return this._dataDynamic[i].value;
			}

			return "";
		}
	}
	
	namespace.ComscorePlugin = ComscorePlugin;
		
})(psd.statistics.plugins);
(function(namespace) {

    // Inheritance class
    ComscoreVideoPlugin.prototype = new psd.statistics.TrackingPlugin();

    // Construct
    function ComscoreVideoPlugin() 
    {
        // Super
        psd.statistics.TrackingPlugin.call(this);

        /**
         * className psd.statistics.OmniturePlugin
         */
        this.className = "psd.statistics.ComscoreVideoPlugin";
		
		var _data = {};
		var settings;
		var settingsUrl;
		
		var eventMap = {'adStart':'01', 'mediaBegin':'03'}
		
		var _configParser;
		var _configMediator;
		
		var parserResult;		
				
		var _importRemoteConfiguration = function(url) {
            _configMediator.corsIE(true);
            _configMediator.mediate(url, _configParser, psd.framework.Mediator.RESPONSE_JSON);
        };
		
		// Listener que escucha el evento MEDIATE_ERROR del mediator del
        // fichero de configuraci�n del manager
        // @param evt El evento de tipo MEDIATE_ERROR disparado
        var _onMediatorError = function(evt) {
            // TO-DO GESTI�N DEL ERROR DE LECTURA
            //console.log("MEDIATE ERROR");
            //console.log(evt.result.msg);
        };
		
		// Listener que escucha el evento MEDIATE_COMPLETE del mediator del
        // fichero de configuraci�n del manager
        // @param evt El evento de tipo MEDIATE_COMPLETE disparado
        var _onMediatorComplete = function(evt) {
					
            parserResult = evt.result.parserResult;            
			
            if(parserResult.code == psd.framework.ParserResult.PARSER_SUCCESS_CODE) {
                _importObjectConfiguration.apply(this, [parserResult.result]);
            }else {
                // TO-DO GESTI�N DEL ERROR DE PARSEO
                console.log("PARSER ERROR");
                console.log(parserResult.msg);
            }
        };
		
		var _importObjectConfiguration = function(_settings) {
			settings = _settings;
		}
		
		/**
         * Importa la configuraci�n de un fichero remoto o un objeto local
         * @param settings String con la url a un json de configuraci�n o un 
         *                 objeto de configuraci�n 
         */
        this.setup = function(settings) {

			settingsUrl = settings;
		
			var dependencesUrls = [];
			dependencesUrls.push("http://b.scorecardresearch.com/beacon.js");
		
			var libraryParams = {depends: dependencesUrls
				, success: onDependencesComplete
				, error: onDependencesError
				, scope: this
			};
			
			LibraryManager.load(libraryParams);
		}
		
		/**
         * Importa la configuraci�n de un fichero remoto o un objeto local
		 */
		var onDependencesComplete = function() 
		{
			_configParser = new psd.framework.parser.JSONParser();
			
			_configMediator = new psd.framework.Mediator();
			_configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_COMPLETE, _onMediatorComplete, this);       
			_configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_ERROR, _onMediatorError, this);
			
			_importRemoteConfiguration.apply(this, [settingsUrl]);
		}	

		var onDependencesError = function() {
		}
		
		/**
         * Realiza el seguimiento de un evento en la aplicaci�n
         * @param event El evento que se ha producido
         * @param type El modo de marcado que se debe utilizar para el evento. Por
         *              lo general ser� "custom", pero tambi�n se pueden esperar
         *              modos como "media" o "properties"
         * @param data Datos relacionados con el evento y de car�cter general
         * TO-DO Utilizar "type" para seleccionar el tipo de seguimiento que
         * se hace: custom, Media,...
         */
        this.track = function(event, type, data) {
		
			_data = {C1:'',C2:'',C3:'',C4:'',C5:'',C6:'',C10:''}
		
			if(eventMap[event]!=undefined){
			
				if(typeof(settings.config)!="undefined")
				{   	
					for(i in settings.config.dataMapping){
						_name = settings.config.dataMapping[i].name;
						_value = settings.config.dataMapping[i].value;
	
						if(_value.indexOf("data.")>-1){
							valueAux = _value.slice("data.".length,_value.length);
							_data[_name] = data[_value];
						}
						else{
							_data[_name] = _value;
						}
					}
				}
				
				_data['C5'] = eventMap[event];
	
				//document.write("ASD");
				
				//document.write(unescape("%3Cscript src='" + (document.location.protocol == "https:" ? "https://sb" : "http://b") + ".scorecardresearch.com/beacon.js' %3E%3C/script%3E")); 
				COMSCORE.beacon({ c1:_data.C1, c2:_data.C2, c3:_data.C3, c4:_data.C4, c5:_data.C5, c6:_data.C6, c10:_data.C10});
				//document.write("<img src='http://b.scorecardresearch.com/p?c1=1&c2=&c3=&c4=&c5=&c6=&c10=&cv=2.0&cj=1' />");

                //NOTA: Se comenta este código porque estaba reportando 2 veces las estadísticas de comscore. Se corresponde con <noscript>, es decir para poder registrar estadísticas cuando no hay javascript, con lo
                //cual es absurdo meterlo aquí.
				/*var oImg=document.createElement("img");
				oImg.setAttribute('src', 'http://b.scorecardresearch.com/p?c1=' + _data.C1 + '&c2=' + _data.C2 + '&c3=' + _data.C3 + '&c4=' + _data.C4 + '&c5=' + _data.C5 + '&c6=' + _data.C6 + '&c10=' + _data.C10 + '&cv=2.0&cj=1&event=' + event);
				oImg.setAttribute('alt', 'na');
				oImg.setAttribute('height', '1px');
				oImg.setAttribute('width', '1px');
				document.body.appendChild(oImg);*/
			}
		}
	}
	
	namespace.ComscoreVideoPlugin = ComscoreVideoPlugin;
		
})(psd.statistics.plugins);
(function(namespace) {

    // Inheritance class
    HeartBeatPlugin.prototype = new psd.statistics.TrackingPlugin();

    // Construct
    function HeartBeatPlugin()
    {

        // Super
        psd.statistics.TrackingPlugin.call(this);

        /**
         * className psd.statistics.HeartBeatPlugin
         */
        this.className = "psd.statistics.HeartBeatPlugin";

        ///.............
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                           INTERNALS                                //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

        // Mapa de eventos que gestiona el plugin
        //var _eventMappings = {};

        // Importa la configuración del plugin a partir de un objeto de configuración.
        // El objeto de configuración debe tener la siguiente estructura:
        //  OBJ
        //   |- config
        //        |---- [events] (Array)
        //                 |--------------- {name, events, vars, suites}
        //        |---- [dataMapping] (Array)
        //                 |--------------- {name, value}
        //
        // @param settings Objeto con la configuración que se quiere transferir.
        var _importObjectConfiguration = function(settings) {

            this.loadDynamics(settings);


            // Comprobamos que existe la propiedad principal "config"
            if(typeof(settings.config)!="undefined")
            {
                var events  = settings.config.events,
                    mapping = settings.config.dataMapping,
                    i, length;

                // Utilizamos la API pública addEventMapping() para importar
                // las definiciones de mapeo de eventos
                if(Object.prototype.toString.call(events)=="[object Array]"){

                    for(i=0;i<events.length;i++) {
                        if(typeof(events[i])!="undefined" &&
                            typeof(events[i].name)!="undefined" &&
                            typeof(events[i].events)!="undefined" &&
                            typeof(events[i].vars)!="undefined" &&
                            typeof(events[i].suites)!="undefined") {

                            this.addEventMapping(events[i].name,
                                events[i].events,
                                events[i].vars,
                                events[i].suites);
                        }
                    }
                }

                // Utilizamos la API pública addDataMapping() para importar
                // las definiciones de mapeo de datos
                if(Object.prototype.toString.call(mapping)=="[object Array]"){

                    for(i=0;i<mapping.length;i++) {
                        if(typeof(mapping[i])!="undefined" &&
                            typeof(mapping[i].name)!="undefined" &&
                            typeof(mapping[i].value)!="undefined") {

                            this.addDataMapping(mapping[i].name,
                                mapping[i].value);
                        }
                    }
                }
            }
        };

        // Carga la configuración del plugin a partir de un objeto de configuración
        // remoto. El fichero de configuración debe estar en formato JSON y tener la
        // siguiente estructura:
        //{
        //    "config":{
        //        "events": [
        //            {
        //                "name": "mediaBegin",
        //                "events": "event11",
        //                "vars": "eVar2,eVar3,eVar4,eVar8,eVar17,eVar20,eVar30,eVar35,eVar42,eVar48,eVar74",
        //                "suites": "prisacomaspreprod,suite_producto"
        //            },{
        //                "name": "mediaComplete",
        //                "events": "event12",
        //                "vars": "eVar2,eVar3,eVar4,eVar8,eVar17,eVar20,eVar30,eVar35,eVar42,eVar48,eVar74",
        //                "suites": "prisacomaspreprod,suite_producto"
        //            }
        //        ],
        //        "dataMapping": [
        //            {"name": "eVar8", "value": "data.name" },
        //            {"name": "eVar9", "value": "data.adName" },
        //            {"name": "eVar74", "value": "data.duration" }
        //        ]
        //    }
        //}
        // @param url URL con la dirección del fichero de configuración.
        var _importRemoteConfiguration = function(url) {
            _configMediator.corsIE(true);
            _configMediator.mediate(url, _configParser, psd.framework.Mediator.RESPONSE_JSON);
        };

        // Listener que escucha el evento MEDIATE_COMPLETE del mediator del
        // fichero de configuración del manager
        // @param evt El evento de tipo MEDIATE_COMPLETE disparado
        var _onMediatorComplete = function(evt) {
            var parserResult = evt.result.parserResult;

            if(parserResult.code == psd.framework.ParserResult.PARSER_SUCCESS_CODE) {
                _importObjectConfiguration.apply(this, [parserResult.result]);
            }else {
                // TO-DO GESTIÓN DEL ERROR DE PARSEO
                console.log("PARSER ERROR");
                console.log(parserResult.msg);
            }
        };

        // Listener que escucha el evento MEDIATE_ERROR del mediator del
        // fichero de configuración del manager
        // @param evt El evento de tipo MEDIATE_ERROR disparado
        var _onMediatorError = function(evt) {
            // TO-DO GESTIÓN DEL ERROR DE LECTURA
            console.log("MEDIATE ERROR");
            console.log(evt.result.msg);
        };

        // Mediator para la carga de ficheros de configuración
        var _configMediator = new psd.framework.Mediator();
        _configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_COMPLETE, _onMediatorComplete, this);
        _configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_ERROR, _onMediatorError, this);

        // Parser para la carga de ficheros de configuración
        var _configParser = new psd.framework.parser.JSONParser();

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                              API                                   //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

        /**
         * Importa la configuración de un fichero remoto o un objeto local
         * @param settings String con la url a un json de configuración o un
         *                 objeto de configuración
         */
        this.setup = function(settings) {

            var settingsType = Object.prototype.toString.call(settings);

            // Iniciamos la carga remota si el parámetro es un String, o la carga
            // local si e
            // l parámetro es un Object
            if(settingsType=="[object String]") {
                _importRemoteConfiguration.apply(this, [settings]);
            } else if(settingsType=="[object Object]") {
                _importObjectConfiguration.apply(this, [settings]);
            }


            if((typeof(s)==="undefined") && (typeof(s_gi)!=="undefined"))
                s = s_gi("");
        };

        /**
         * Realiza el seguimiento de un evento en la aplicación
         * @param event El evento que se ha producido
         * @param type El modo de marcado que se debe utilizar para el evento. Por
         *              lo general será "custom", pero también se pueden esperar
         *              modos como "media" o "properties"
         * @param data Datos relacionados con el evento y de carácter general
         * TO-DO Utilizar "type" para seleccionar el tipo de seguimiento que
         * se hace: custom, Media,...
         */
        this.track = function(event, type, data) {
            console.log("*Evento HeartBeat-->",event);
            console.log("*Tipo HeartBeat-->",type);
            console.log("*Datos HeartBeat-->",data);

        /*    var VID=new VideoPlayer('movie');

            VID._onPlay();
            console.log(">>> obj invocado: ",VID._onPlay()); */

        };

        /**
         * Crea una nueva regla de mapeo para un evento
         * @param name Nombre del evento
         * @param events Eventos que se deben registrar en la suite de omniture
         * @param vars Variables que se deben registrar en la suite de omniture
         * @param suites Cuentas en las que se debe registrar la acción
         */
        this.addEventMapping = function(name, events, vars, suites) {
            _eventMappings[name] = {events: events.split(","), vars: vars.split(","), suites:suites};
        };
        ///.............
        console.log("Plugin HeartBeat Activo")
    }
    // Incluimos la declaracion de la clase en el namespace psd.statistics
    namespace.HeartBeatPlugin = HeartBeatPlugin;

})(psd.statistics.plugins);(function(namespace) {

    // Inheritance class
    LogTrustPlugin.prototype = new psd.statistics.TrackingPlugin();

    // Construct
    function LogTrustPlugin()
    {
        // Super
        psd.statistics.TrackingPlugin.call(this);

        /**
         * className psd.statistics.LogTrustPlugin
         */
        this.className = "psd.statistics.LogTrustPlugin";

        //URl y envio de pixel
        //var logtrustURL="http://localhost/psdmedia/tests/statistics/tests/img/control.gif"; //--URL de envio local
        var logtrustURL="http://tracking.logtrust.io/pixel/ffduH8fQryYdIkaE0A0YSQ.gif"; //--URL de envio Logtrusts

        var objImagen = new Image();


            //.............


        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                           INTERNALS                                //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

        // Mapa de eventos que gestiona el plugin
        var _eventMappings = {};

        // Importa la configuración del plugin a partir de un objeto de configuración.
        // El objeto de configuración debe tener la siguiente estructura:
        //  OBJ
        //   |- config
        //        |---- [events] (Array)
        //                 |--------------- {name, events, vars, suites}
        //        |---- [dataMapping] (Array)
        //                 |--------------- {name, value}
        //
        // @param settings Objeto con la configuración que se quiere transferir.
        var _importObjectConfiguration = function(settings) {

            this.loadDynamics(settings);


            // Comprobamos que existe la propiedad principal "config"
            if(typeof(settings.config)!="undefined")
            {
                var events  = settings.config.events,
                    mapping = settings.config.dataMapping,
                    i, length;

                // Utilizamos la API pública addEventMapping() para importar
                // las definiciones de mapeo de eventos
                if(Object.prototype.toString.call(events)=="[object Array]"){

                    for(i=0;i<events.length;i++) {
                        if(typeof(events[i])!="undefined" &&
                            typeof(events[i].name)!="undefined" &&
                            typeof(events[i].events)!="undefined" &&
                            typeof(events[i].vars)!="undefined" &&
                            typeof(events[i].suites)!="undefined") {

                            this.addEventMapping(events[i].name,
                                events[i].events,
                                events[i].vars,
                                events[i].suites);
                        }
                    }
                }

                // Utilizamos la API pública addDataMapping() para importar
                // las definiciones de mapeo de datos
                if(Object.prototype.toString.call(mapping)=="[object Array]"){

                    for(i=0;i<mapping.length;i++) {
                        if(typeof(mapping[i])!="undefined" &&
                            typeof(mapping[i].name)!="undefined" &&
                            typeof(mapping[i].value)!="undefined") {

                            this.addDataMapping(mapping[i].name,
                                mapping[i].value);
                        }
                    }
                }
            }
        };

        // Carga la configuración del plugin a partir de un objeto de configuración
        // remoto. El fichero de configuración debe estar en formato JSON y tener la

        // @param url URL con la dirección del fichero de configuración.
        var _importRemoteConfiguration = function(url) {
            _configMediator.corsIE(true);
            _configMediator.mediate(url, _configParser, psd.framework.Mediator.RESPONSE_JSON);
        };

        // Listener que escucha el evento MEDIATE_COMPLETE del mediator del
        // fichero de configuración del manager
        // @param evt El evento de tipo MEDIATE_COMPLETE disparado
        var _onMediatorComplete = function(evt) {
            var parserResult = evt.result.parserResult;

            if(parserResult.code == psd.framework.ParserResult.PARSER_SUCCESS_CODE) {
                _importObjectConfiguration.apply(this, [parserResult.result]);
            }else {
                // TO-DO GESTIÓN DEL ERROR DE PARSEO
                console.log("PARSER ERROR");
                console.log(parserResult.msg);
            }
        };

        // Listener que escucha el evento MEDIATE_ERROR del mediator del
        // fichero de configuración del manager
        // @param evt El evento de tipo MEDIATE_ERROR disparado
        var _onMediatorError = function(evt) {
            // TO-DO GESTIÓN DEL ERROR DE LECTURA
            console.log("MEDIATE ERROR");
            console.log(evt.result.msg);
        };

        // Mediator para la carga de ficheros de configuración
        var _configMediator = new psd.framework.Mediator();
        _configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_COMPLETE, _onMediatorComplete, this);
        _configMediator.addEventListener(psd.framework.MediatorEvent.MEDIATE_ERROR, _onMediatorError, this);

        // Parser para la carga de ficheros de configuración
        var _configParser = new psd.framework.parser.JSONParser();

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//
        //                              API                                   //
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//

        /**
         * Importa la configuración de un fichero remoto o un objeto local
         * @param settings String con la url a un json de configuración o un
         *                 objeto de configuración
         */
        this.setup = function(settings) {

            var settingsType = Object.prototype.toString.call(settings);

            // Iniciamos la carga remota si el parámetro es un String, o la carga
            // local si e
            // l parámetro es un Object
            if(settingsType=="[object String]") {
                _importRemoteConfiguration.apply(this, [settings]);
            } else if(settingsType=="[object Object]") {
                _importObjectConfiguration.apply(this, [settings]);
            }


            if((typeof(s)==="undefined") && (typeof(s_gi)!=="undefined"))
                s = s_gi("");
        };

        /**
         * Realiza el seguimiento de un evento en la aplicación
         * @param event El evento que se ha producido
         * @param type El modo de marcado que se debe utilizar para el evento. Por
         *              lo general será "custom", pero también se pueden esperar
         *              modos como "media" o "properties"
         * @param data Datos relacionados con el evento y de carácter general
         * TO-DO Utilizar "type" para seleccionar el tipo de seguimiento que
         * se hace: custom, Media,...
         */
        this.track = function(event, type, data) {
//           console.log("***LogTrust OK****");
//           console.log("***data-->",data);
//           console.log("***Type-->",type);
//           console.log("***datamap-->",this.dataMap());
           eventMap = _eventMappings[event];
//           console.log("***Eventos-->",eventMap);


            var _mapaData = data;

            var _mapaDataMap = this.dataMap();

            var varAux1, varAux2;
            var sendlogTrust = {};//obj envio de variables
            var sizeString = 0;
            var totalSizeString = 0;
            var dataVar = [
                "data.name",//--TopPlayer //--s.pageName
                "data.duration",//--TopPlayer
                "data.mediaType",//--TopPlayer
                "data.channelSection",//--s.prop30
                "data.topPageTitle",//--document.location.href
                "data.trafficsource",//--document.referrer
                "data.adposition",//--TopPlayer
                "data.channel",//--s.prop17
                "data.uid",//--s.prop34
                "data.domain",//--s.prop20
                "data.idTop",//--TopPlayer
                "data.channelSubsection"//--s.prop31

            ];

            //--Capturando objetos globales


            //---Variables para medios compatibles


            try {

                if (s.pageName !== undefined && s.pageName != "") {

                    _mapaData[dataVar[0]] = s.pageName;
                }


                if (s.prop30 !== undefined && s.prop30 != "") {

                    _mapaData[dataVar[3]] = s.prop30;
                }


                if (s.prop17 !== undefined && s.prop17 != "") {

                    _mapaData[dataVar[7]] = s.prop17;
                }

                if (s.prop34 !== undefined && s.prop34 != "") {

                    _mapaData[dataVar[8]] = s.prop34;
                }


                if (s.prop20 !== undefined && s.prop20 != "") {

                    _mapaData[dataVar[9]] = s.prop20;
                }else{

                    _mapaData[dataVar[9]] = location.hostname.replace(/www./gi, "");
                }


                if (s.prop31 !== undefined && s.prop31 != "") {

                    _mapaData[dataVar[11]] = s.prop31;
                }


                if (window.top.document.location.href != "") {
                    _mapaData[dataVar[4]] = window.top.document.location.href;
                }


                if (window.top.document.referrer != "") {
                    _mapaData[dataVar[5]] = window.top.document.referrer;
                }


                //---configuracion para SimpleMediaPlayer(Meristation)

                var dataLive = _mapaData["data.live"];

                if (dataLive !== undefined) {


                    _mapaData[dataVar[2]] = (_mapaData["data.mediaType"].indexOf("video") != -1) ? "VOD" : "AOD";

                    if (dataLive) {

                        _mapaData[dataVar[2]] = (_mapaData[dataVar[2]].indexOf("VOD") != -1) ? "V_Streaming" : "A_Streaming";

                    }
                }



            } catch (err) {

                console.log(">>Var error: ", err);
            }


            /* if (eventMap.events[0] == "event11" || eventMap.events[0] == "event12") {

             _mapaData[dataVar[6]] = "media";

             } else {

             _mapaData[dataVar[6]] = (window._request);

             }*/


          //****************Conversion de Datos***************

            //Configuracion de Eventos


                for (var c1 in _mapaData) {



                    varAux1 = c1;

                    //Configuracion de variables
                    for (var c2 in _mapaDataMap) {


                        varAux2 = _mapaDataMap[c2];

                        if (varAux1 == varAux2) {


                            sendlogTrust[c2] = _mapaData[c1];//captura variables utiles

                            totalSizeString++;

                        }


                    }

                }


            //--Composicion y envio de datos

            (function (){


                var compoURL = "?event="+eventMap.events[0]+"&";


                for (var c3 in sendlogTrust) {

                    sizeString++;

                    compoURL += c3 + "=" + sendlogTrust[c3];

                    if (sizeString != totalSizeString) {
                        compoURL += "&";
                    } else {
                        compoURL += "";

                    }

                }

//                console.log("obj sendlogTrust*=", sendlogTrust);

                objImagen.src = logtrustURL + compoURL;

//                console.log("Evento=", event);

                //delete sendlogTrust;


            }())//--Envio



            //****************Fin de Conversion de Datos********



        };

        /**
         * Crea una nueva regla de mapeo para un evento
         * @param name Nombre del evento
         * @param events Eventos que se deben registrar en la suite de omniture
         * @param vars Variables que se deben registrar en la suite de omniture
         * @param suites Cuentas en las que se debe registrar la acción
         */
        this.addEventMapping = function(name, events, vars, suites) {
            //*****%%
            _eventMappings[name] = {events: events.split(","), vars: vars.split(","), suites:suites};

        };


            //.............

        console.log("> Plugin Logtrust Activado")
    }

    // Incluimos la declaracion de la clase en el namespace psd.statistics
    namespace.LogTrustPlugin = LogTrustPlugin;

})(psd.statistics.plugins);(function(namespace) {
	
    // Inheritance class
    StatEvent.prototype = new psd.framework.Event();

    StatEvent.DATA_REQUIRED_STATISTICS = "dataRequired";
    
    this.data = null;
	this.dataAsync = null;
	this.plugin = null;

    /**
     * Eventos de estado de reproduccion de contenido multimedia
     * @constructor
     */
    function StatEvent(type, dataAsync, data, plugin) 
    {
        // Super
        psd.framework.Event.call(this, type);
        
        this.data = data;
		this.dataAsync = dataAsync;
		this.plugin = plugin;
    }
    
    // Incluimos la declaracion de la clase en el namespace psd.media	
    namespace.StatEvent = StatEvent;

})(psd.statistics);(function(namespace) {

    /**
     * Gestor de cargas de dependencias de javascript.
     * Permite la carga de múltiples dependencias simultáneas y una cola
     * de cargas para peticiones diferentes
     * @constructor
     */
    function LibraryManager() 
    {
        // Array de librerías ya cargadas por el gestor
        var _loadedDependencies = [];
        
        // Cola de carga
        var _loadingQueue = [];
        
        // Elemento de carga actual
        var _loading = null;
        
        // Dependencia de carga actual
        var _loadingDependency = null;
        
        /**
         * Carga librerias de manera dinamica
         * @param loadItem Elemento con información de la carga. Consta de:
         *          .depends: Array de dependencias a cargar
         *          .success: Callback para cuando se completa la carga correctamente
         *          .error: Callback para cuando falla la carga
         *          .scope: Scope a aplicar para las llamadas de los callbacks
         */
        this.load = function(loadItem) 
        {
            var itemValidation = _validateItem(loadItem);
            
            if(itemValidation!="") { if(psd.framework.debug) {console.log('Invalid load item: ' +itemValidation);} return; }
            
            if( _checkDependencies(loadItem.depends)) { loadItem.success.apply(loadItem.scope); }
            else{ _loadDependencies(loadItem); }
        };
        
        // Valida que un elemento que se quiere cargar es valido
        _validateItem = function(loadItem)
        {
            var validation = "";
            
            if(typeof(loadItem)=='undefined') { validation = "null loaditem"; }
            if(typeof(loadItem.depends)=='undefined') { validation = "null depends"; }
            if(loadItem.depends!=null && typeof(loadItem.depends)!='string' && typeof(loadItem.depends)!='object') { validation = "illegal depends type "+typeof(loadItem.depends); }
            if(typeof(loadItem.success)!='function') { validation = "success is not a function"; }
            if(typeof(loadItem.error)!='function') { validation = "error is not a function"; }
            
            // Si el elemento src es un unico string, lo convertimos en array
            if(typeof(loadItem.depends)=='string') { loadItem.depends = [loadItem.depends]; }
            
            return validation;
        };
        
        // Comprueba si una lista de dependencias ya ha sido cargada por completo
        _checkDependencies = function(dependencies)
        {
            var i, dependenciesReady = true;
         
            for(i in dependencies)
            {
                dependenciesReady = dependenciesReady && _checkDependency(dependencies[i]);
                if(!dependenciesReady) { break; }
            }
            
            return dependenciesReady;
        };
        
        // Comprueba si una depencia ya ha sido cargada
        _checkDependency = function(dependency)
        {
            var i;
            for(i in _loadedDependencies) { if(_loadedDependencies[i] == dependency) { return true; } }
            return false;
        };
                
        // Inicia la carga de una lista de dependencias
        _loadDependencies = function(loadingItem)
        {
            var i;
            
            if((_loading==null && _loadingQueue.length==0)||_loading==loadingItem)
            {
                _loading = loadingItem;

                if(_checkDependencies(loadingItem.depends)) { _dependencyLoaded(); }
                else{
                    for(i in loadingItem.depends)
                    {
                        if(!_checkDependency(loadingItem.depends[i])) { _loadDependency(loadingItem.depends[i]); break; }
                    }
                }
                
            }else{ _loadingQueue.push(loadingItem); }
        };
        
        // Inicia la carga de una dependencia
        _loadDependency = function(dependency)
        {
            if(psd.framework.debug) {console.log("loading dependency "+dependency);}  
            _loadingDependency = dependency;
            
            var head = document.getElementsByTagName('head')[0];
            var script = document.createElement('script');
            script.type = 'text/javascript';

            if (navigator.appName.indexOf("Microsoft") >= 0) {
                script.onreadystatechange = function() {
                    if (this.readyState == "loaded" ||
                        this.readyState == "complete") {
                        _dependencyLoaded();
                        script.onreadystatechange = null;
                    }
                };
            }
            else {
                script.onload = _dependencyLoaded;
            }
            
            script.src = _loadingDependency;

            head.appendChild(script);                        
        };
        
        // Detecta la carga completa de una dependencia y continua con el proceso
        // de carga de la lista de dependencias actual
        _dependencyLoaded = function()
        {
            if(psd.framework.debug) {console.log("successfully loaded dependency " + _loadingDependency);}
            _loadedDependencies.push(_loadingDependency);
            _loadingDependency = "";
            
            if(!_checkDependencies(_loading.depends)) { _loadDependencies(_loading); }
            else { 
                _loading.success.apply(_loading.scope); 
                _loading=null;
                
                if(_loadingQueue.length>0) 
                { 
                    _loading = _loadingQueue.shift();
                    _loadDependencies(_loading); 
                }
            }
        };
    }

    // Incluimos la declaracion de la clase en el namespace psd.framework
    namespace.LibraryManager = new LibraryManager();

}(window));